---
title: "Frame Pointer Overflow"
tags: [fpo, "pwnable theory"]
categories: [System]
---

Frame Pointer Overflow(with. Off by one)
----------------------------------------

# Index


## What is Frame Pointer Overflow?

FPO(Frame Pointer Overflow)는 SFP(Stack Frame Pointer)의 1Byte를 overflow하여 EIP를 변경하여 결과적으로 프로그램의 흐름을 변조하는 기법입니다. FPO 기법을 이해하기 이전 Off-by-one 기법에 대해 이해할 필요가 있었습니다.

### Off-by-One

Off-by-one 취약점은 경계 검사에서 하나의 오차가 있을 때 발생하는 취약점으로 주로 버퍼의 경계 계산 혹은 반복문에서 `<`와 `<=`의 오용 등이 취약점의 주된 발생 원인입니다. Off-by-one을 가장 쉽게 이해할 수 있는 예시로 `strcpy()` 함수가 있었습니다.

- strcpy()

`strcpy()` 함수는 대상 문자열을 지정 위치로 복사해주는 함수입니다. 이때 복사한 문자열의 맨 마지막에 **NULL** 문자를 추가해주는데 이를 고려하지 않으면 NULL 문자 1Byte가 추가되어 Off-by-one 취약점이 발생될 수 있습니다.

### 함수 호출 과정

FPO를 이해하기 위해서는 우선 Frame Pointer를 이해할 필요가 있습니다. SFP 라고도 하는 Frame Pointer는 함수 호출 과정에서 이전 함수의 EBP 주소를 저장하고 있는 공간입니다. 함수가 호출될 때 실행되는 과정을 Prologue, 종료될 때 실행되는 과정을 Epilogue 라고 합니다. `CALL`에 의해서 함수가 호출될 때부터 Prolog 과정 동안 Stack에는 다음과 같은 변화가 일어납니다.

1. 함수 호출

CALL 명령에 의해 함수가 호출되면 gdb와 같은 도구로 확인하였을 때는 바로 prologue 단계로 넘어간 것처럼 확인됩니다. 그러나 호출 전과 후의 rsp(혹은 esp) 값을 확인해보면 감소해 있는 것을 확인할 수 있습니다. 값이 감소되는 원인으로는 `push`를 예상할 수 있는데 stack은 "LIFO" 구조를 가지고 있기 때문에 가장 최근에 넣은 값이 낮은 주소에 위치하게 됩니다. 반면에 인터넷을 통해 자료를 찾아보면, SFP보다 높은 주소에 RET 값이 존재하는 것을 확인할 수 있습니다.

<p align="center">[RET와 SFP 이미지](!https://t1.daumcdn.net/cfile/tistory/222966395443F64C0D)</p>

이를 통해서 CALL 과정 중 RET 주소와 관련된 작업이 있다는 것을 유추할 수 있습니다. RET 주소는 함수의 호출이 종료된 후 진행할 다음 명령의 위치를 가리킵니다. 이는 곧 호출 전 caller의 rip(혹은 eip) 주소와 같은 의미이며 따라서 `push rip` 후 `jmp`를 통해 callee로 이동한다는 것을 알 수 있습니다.


* * *

## Reference

- <https://d4m0n.tistory.com/76>

- <https://aistories.tistory.com/12>
