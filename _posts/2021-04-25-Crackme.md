---
title: "Reversing.kr Crackme 부분 분석"
tags: ["reversing", "assembly", "wargame"]
categories: [reversing, assembly, "reversing theory"]
---

# Index

1. [목적](#purpose)
2. [사전 지식](#background-theory)
3. [분석 코드](#code)

* * *

## Purpose

첫 Reversing.kr Crackme 문제 풀이를 시도하였습니다. 이전에 풀었던 dreamhack의 문제는 초반 부분의 문제에서 어느정도 일정한 형태를 갖고 있었기에 분석이 비교적 편했지만 이 문제의 경우 Main을 찾기부터 수월하진 않았습니다.

여차저차 프로그램의 Main과 문제 풀이에 중점이 되는 function도 발견할 수 있었으나 기존에 봐왔던 assembly가 아닌 `repne scasb`, `repe cmpsb` 와 같은 언뜻 봤을 때 인자가 없는 형태의 명령을 처음 봐서 많은 어려움을 겪었습니다.

해당 명령들에 대해서 구글에 서치도 하였으나 과정보다는 결과에 있어서만 이해가 되서 직접 register 값들의 변화와 관련된 flag들의 변화를 살펴보며 해석한 내용을 기술하고자 글을 작성하였습니다. 어디까지나 "정답"은 아니며 과정과 결과에서 비롯된 결론이기에 잘못된 정보가 포함되어 있을 수도 있습니다.

## Background Theory

~~우선 cmp와 유사한 명령으로 생각되는 cmpsb를 제외하고는 모두 처음 보는 명령들이기에 기본적인 동작에 대해 검색을 하였습니다.~~

내용을 검색하다보니 cmps 또한 cmp와 다른 명령이었습니다...

- **REP** 계열

여기서는 REPE와 REPNE 두 가지가 사용되었는데 모두 REP를 기반으로 된 명령임을 찾을 수 있었습니다. Repeat 즉, 반복적으로 실행해주는 명령으로 기존에 jmp를 통해서 특정 조건을 만족하기 전까지 반복시켜주는 형태와는 다르게 특정 명령의 반복을 쉽게 처리할 수 있게 해주는 것으로 보였습니다. 상세한 내용은 [링크](https://docs.oracle.com/cd/E19455-01/806-3773/instructionset-64/index.html)를 통해서 확인할 수 있습니다.

기본적인 REP의 동작 조건의 경우 `ecx > 0` 인 경우로 ecx에 만약 5라는 값이 할당되어 있다면 뒤따라오는 명령을 5번 반복합니다. REPE와 REPNE는 기본 조건에서 **Zero Flag**와 관련된 조건이 추가된 명령입니다. 각각 다음과 같습니다.

```
=> REPE(=REPZ) : Zero Flag가 1이고 ecx > 0인 동안 반복
=> REPNE(=REPNZ) : Zero Flag가 0이고 ecx > 0인 동안 반복
```

* * *

- **SCAS** 계열

SCAS는 String을 비교할 수 있는 명령으로 비교하는 크기에 따라 Byte 단위의 SCASB, Word 단위의 SCASW, DWORD 단위의 SCASD로 구분할 수 있습니다. 또다른 유사한 명령으로는  cmps가 있는데  cmpis와 가장 큰 차이점은 EAX Register의 값과 EDI 값을 비교한다는 점입니다. 자세한 내용은 [링크](https://m.blog.naver.com/PostView.nhn?blogId=heobk1&logNo=221407406445&proxyReferer=https:%2F%2Fwww.google.com%2F)에서 확인할 수 있었습니다.

SCAS 명령은 실행하였을 때 값이 같을 경우 Zero Flag를 1로 설정하며 같지 않을 경우 0으로 설정하여 결과를 반환한다고 합니다.

* * *

- **CMPS** 계열

CMPS는 메모리와 메모리를 비교하는 명령으로 ESI와 EDI의 내용을 비교하여 같을 경우 Zero Flag를 1로, 다를 경우 0으로 결과를 반환합니다. 다른 명령어와 공통적으로 b는 byte, w는 word, d는 dword를 의미합니다.

## Code

우선 전체 코드 중 분석할 부분의 전체적인 흐름은 아래와 같았습니다.

```
push    ebp
mov     ebp, esp
push    edi
push    esi
push    ebx
mov     ecx, [ebp+arg_8]
jecxz   short loc_401181
mov     ebx, ecx
mov     edi, [ebp+arg_0]
mov     esi, edi
xor     eax, eax
repne scasb
neg     ecx
add     ecx, ebx
mov     edi, esi
mov     esi, [ebp+arg_4]
repe cmpsb
mov     al, [esi-1]
xor     ecx, ecx
cmp     al, [edi-1]
ja      short loc_40117F
jz      short loc_401181
dec     ecx
dec     ecx

not     ecx

mov     eax, ecx
pop     ebx
pop     esi
pop     edi
leave
```


